<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title> PROJECT 1 </title>
<meta name="generator" content="Jekyll v3.7.3">
<meta property="og:title" content="Genady Maryash, Hunter College">
<meta property="og:locale" content="en_US">
<link rel="canonical" href="https://maryash.github.io/">
<meta property="og:url" content="https://maryash.github.io/">
<meta property="og:site_name" content="maryash.github.io">
<script type="application/ld+json">
{"name":"maryash.github.io","@type":"WebSite","url":"https://maryash.github.io/","headline":"Genady Maryash, Hunter College","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <style class="anchorjs"></style><link href="Project%201_files/css.css" rel="stylesheet"> 

    <!-- MathJax -->
    <script type="text/javascript" async="" src="Project%201_files/MathJax.js">
    </script>

<!--   <link crossorigin="anonymous" media="all" integrity="sha512-Z0JAar9+DkI1NjGVdZr3GivARUgJtA0o2eHlTv7Ou2gshR5awWVf8QGsq11Ns9ZxQLEs+G5/SuARmvpOLMzulw==" rel="stylesheet" href="https://assets-cdn.github.com/assets/frameworks-95aff0b550d3fe338b645a4deebdcb1b.css" />
    --> 
<!--   <link crossorigin="anonymous" media="all" integrity="sha512-yv+kWn8ewbavFKfvLZifQplJ0chJ6H894rDwGVvn0LtaG80VxAQmPt8pRMMOSlGNSiPwZEDSVzZjyOOiVe0eyA==" rel="stylesheet" href="https://assets-cdn.github.com/assets/github-37504d684728c80db863d719b4ac6781.css" />
    --> 
<link rel="stylesheet" href="Project%201_files/style.css">
  <style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
  <body><div id="MathJax_Message" style="display: none;"></div>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <p style="text-align: center; font-style: italic;">Important</p>
<p>You must start working on the projects as soon as they are assigned 
to detect any problems and to address them with us well before the 
deadline so that we have time to get back to you before the deadline.</p>

<p><strong>There will be no extensions and no negotiation about project grades after the submission deadline.</strong></p>

<hr>

<h1 id="project-1-hang-in-there">Project 1: Hang in there!</h1>

<p><em><strong>Welcome students! You’ve been working on the labs and 
homeworks so far. Its time to take it up a notch. Use everything you’ve 
learned so far and hang in there!</strong></em></p>
<p align="center">
    <img src="Project%201_files/hangin.gif" alt="hangin">
</p>

<h2 id="introduction">Introduction<a class="anchorjs-link " href="#introduction" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p>Using what you’ve learned, we will create a dictionary. Later, we will implement Hangman using the dictionary.</p>

<p>Things you need to know for this project: <a href="https://www.geeksforgeeks.org/arrays-in-c-cpp/">Arrays</a>, <a href="https://www.geeksforgeeks.org/functions-in-cpp/">Functions</a>,  <a href="https://www.geeksforgeeks.org/scope-of-variables-in-c/">Global-Variables</a>, <a href="https://www.geeksforgeeks.org/substring-in-cpp/">String-Manipulation</a></p>

<hr>
<h2 id="implementation">Implementation:<a class="anchorjs-link " href="#implementation" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>

<p><strong>Work incrementally!</strong> Work through the tasks 
sequentially (implement and test). Only move on to a task when you are 
positive that the previous one has been completed correctly. Remember 
that the <strong>function prototypes and global-variables must be exactly as specified in this project specification</strong>. Lastly, <strong>do NOT use EOF(End of File), vector, or any library that we haven’t learned yet in class.</strong> If you don’t understand this project specification and its requirements, ask for clarification before you proceed. <strong>TEST YOUR CODE BEFORE SUBMITTING!!!</strong></p>

<hr>

<h2 id="task-a-dictionary-using-arrays">Task A: Dictionary using Arrays<a class="anchorjs-link " href="#task-a-dictionary-using-arrays" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>
<p align="center">
    <img src="Project%201_files/horrible.jpg" alt="horrible" width="600">
</p>

<p>A regular dictionary contains the words and the definitions. In 
addition to the words and the definitions, we will also store the 
part-of-speech (pos). The words, definitions and pos are going to be 
stored in Arrays. Use these global-variables in your code outside <code class="language-plaintext highlighter-rouge">main()</code> function:</p>

<pre><code class="language-Cpp">const int g_MAX_WORDS = 1000;
int g_word_count = 0;

string g_words[g_MAX_WORDS];
string g_definitions[g_MAX_WORDS];
string g_pos[g_MAX_WORDS];
</code></pre>

<p>Create a C++ file and add the following function:</p>

<pre><code class="language-Cpp">/*
    @param            :   The string with the `filename`
    @post             :   Reads the words, definitions
                          pos into the global-arrays 
                          and set the value of `g_word_count`
                          to the number of words read
*/
void readWords(string filename);
</code></pre>
<p>Here’s an example text file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WORD POS : DEFINITION
Grumpy Adjective : bad-tempered and irritable
Professor Noun : a teacher of the highest rank in a college or university
Does Verb : perform (an action, often of unspecified nature)
Nothing Adverb : not at all
</code></pre></div></div>

<p>Example:</p>

<p>Calling <code class="language-plaintext highlighter-rouge">readWords()</code> on the above text file will modify the global variables like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g_MAX_WORDS: 1000

g_word_count: 5

g_words: ["WORD", "Grumpy", "Professor", "Does", "Nothing"]

g_pos: ["POS", "Adjective", "Noun", "Verb", "Adverb"]

g_definitions: [
    "DEFINITION",
    "bad-tempered and irritable", 
    "a teacher of the highest rank in a college or university", 
    "perform (an action, often of unspecified nature)", 
    "not at all"
]
</code></pre></div></div>
<p><em>Hint: Which lab was this covered in again?</em></p>

<p>Make sure your program produces the correct output by testing the function and global-variables using <code class="language-plaintext highlighter-rouge">main()</code> function.</p>

<p><strong>Note: Only submit single <code class="language-plaintext highlighter-rouge">.cpp</code>
 file to gradescope. Remove or comment out the main function from your 
code before submitting it on gradescope. Otherwise, the autograder will 
fail.</strong></p>

<hr>

<h2 id="task-b-dictionary-operations">Task B: Dictionary Operations<a class="anchorjs-link " href="#task-b-dictionary-operations" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>
<p align="center">
    <img src="Project%201_files/cat.jpg" alt="catto" width="600">
</p>
<p>Now that we have the words stored, it is time to provide functions 
that allow users to use our dictionary. Add and implement the following 
functions:</p>

<pre><code class="language-Cpp">/*
    @param            :   The string with a query word
    @return           :   Integer index of the word in
                          `g_words` global-array. Returns
                          -1 if the word is not found
    @post             :   Find the index of given `word`
                          in the `g_words` array. Return -1
                          if word is not in the array
*/
int getIndex(string word);

/*
    @param            :   The string with a query word
    @return           :   Return the string definition of
                          the word from  `g_definitions`
                          global-array. Return "NOT_FOUND" if
                          word doesn't exist in the dictionary
    @post             :   Find the definition of the given `word`
                          Return "NOT_FOUND" otherwise
*/
string getDefinition(string word);

/*
    @param            :   The string with a query word
    @return           :   Return the string part-of-speech(pos) 
                          from the `g_pos` global-array. Return
                          "NOT_FOUND" if the word doesn't exist
                          in the dictionary.
    @post             :   Find the pos of the given `word`
                          Return "NOT_FOUND" otherwise
*/
string getPOS(string word);

/*
    @param            :   The string prefix of a word (the prefix
                          can be of any length)
    @return           :   Integer number of words found that starts
                          with the given `prefix`
    @post             :   Count the words that start with the given
                          `prefix`
*/
int countPrefix(string prefix);
</code></pre>
<p>Remember to test each function before moving on to implement the next one. Similar to Task A, submit only one <code class="language-plaintext highlighter-rouge">.cpp</code> file without the <code class="language-plaintext highlighter-rouge">main()</code> function.</p>

<hr>

<h2 id="task-c-dictionary-admin-operations">Task C: Dictionary Admin Operations<a class="anchorjs-link " href="#task-c-dictionary-admin-operations" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>
<p align="center">
    <img src="Project%201_files/yeet.jpg" alt="yeeted" width="600">
</p>
<p>Languages evolve constantly. Hundreds of new English words are added 
to the English dictionary each year. Definitions of words change. Thus, 
we should be able to modify, add and remove words in our dictionary. 
Besides, don’t you want to use your own words for hangman? Add and 
implement the following functions to your <code class="language-plaintext highlighter-rouge">.cpp</code> file:</p>

<pre><code class="language-Cpp">/*
    @param word       :   The string with a new word
    @param definition :   The string with the definition of the
                          new `word`
    @param pos        :   The string with the pos of the new `word`
    @return           :   return `true` if the word is
                          successfully added to the dictionary
                          return `false` if failed (word already
                          exists or dictionary is full)
    @post             :   Add the given `word`, `definition`, `pos`
                          to the end of the respective
                          global-arrays.
                          The word should not be added to the
                          global-arrays if it already exists 
                          or if the array reached maximum 
                          capacity(`g_MAX_WORDS`).
                          Update `g_word_count` if the word is
                          successfully added
*/
bool addWord(string word, string definition, string pos);

/*
    @param word       :   The string with the word that is to
                          be edited
    @param definition :   The string with the new definition of 
                          the `word`
    @param pos        :   The string with the new pos of the `word`
    @return           :   return `true` if the word is successfully
                          edited, return `false` if the `word`
                          doesn't exist in the dictionary
    @post             :   Replace the given `word`'s  definition
                          and pos with the given `definition` and
                          `pos` (by modifying global-arrays
                          `g_definitions` and `g_pos`).
                          The modification will fail if the word
                          doesn't exist in the dictionary
*/
bool editWord(string word, string definition, string pos);

/*
    @param            :   The string with the word that is to
                          be removed
    @return           :   return `true` if the word is successfully
                          removed from the dictionary return `false`
                          if the word doesn't exist in the dictionary
    @post             :   Remove the given `word`, `word`'s
                          definition and `word`'s pos from the
                          respective global-arrays if the word
                          exists.  
                          Update `g_word_count` if the word is
                          successfully removed
*/
bool removeWord(string word);
</code></pre>
<p><em>Hint: For the <code class="language-plaintext highlighter-rouge">removeWord()</code> function, the order of the global-arrays doesn’t matter. An empty string array is full of empty strings (“”)</em></p>

<p>You can use the functions you wrote previously within the implementation of Task C functions. The <code class="language-plaintext highlighter-rouge">getIndex()</code> function is extremely useful!</p>

<p>Test each function before moving on to implement the next one. Submit only one <code class="language-plaintext highlighter-rouge">.cpp</code> file without the <code class="language-plaintext highlighter-rouge">main()</code> function similar to the previous tasks.</p>

<hr>

<h2 id="task-d-hangman">Task D: Hangman<a class="anchorjs-link " href="#task-d-hangman" aria-label="Anchor" data-anchorjs-icon="" style="font: 1em / 1 anchorjs-icons; padding-left: 0.375em;"></a></h2>
<p align="center">
    <img src="Project%201_files/game.jpeg" alt="game" width="600">
</p>
<p>Now we are ready to make Hangman! Oh and here is a dictionary you can use:</p>

<p><a href="https://maryash.github.io/135/projects/S23_project_1/dictionary.txt">dictionary.txt</a></p>

<p>The game-loop is a sequence of processes that run continuously as 
long as the game is running. The three main processes that occur in the 
game-loop are input, update, and render. Lucky for you, we have provided
 the game-loop. Make sure to include the following function in your 
program:</p>

<pre><code class="language-Cpp">// game-loop for Hangman
void gameLoop() {
    int difficulty, tries;
    string word, current;
    char letter;
    while (true) {
        cout &lt;&lt; "Welcome to Hangman!" &lt;&lt; endl;
        cout &lt;&lt;  "0. easy\n1. normal\n2. hard\n3. exit\nChoose a difficulty: ";
        cin &gt;&gt; difficulty;
        while (difficulty &lt; 0 || difficulty &gt; 3) {
            cout &lt;&lt;  "Enough horseplay &gt;_&lt; !\n0. easy\n1. normal\n2. hard\n3. exit\nChoose a difficulty: ";
            cin &gt;&gt; difficulty;
        }
        if (difficulty == 3) {
            cout &lt;&lt; "If you're hangry, go grab a bite! See what I did there?" &lt;&lt; endl;
            break;
        }
        word = getRandomWord();
        current = maskWord(word);
        tries = getTries(difficulty);
        while (tries != 0) {
            cout &lt;&lt; "Life: ";
            printAttempts(tries, difficulty);
            cout &lt;&lt; endl &lt;&lt; "Word: "&lt;&lt; current &lt;&lt; endl;
            cout &lt;&lt; "Enter a letter: ";
            cin &gt;&gt; letter;
            
            if (!revealLetter(word, letter, current)) {
                tries--;
            }
            if (current == word) {
                break;
            }
            if (tries == 2) {
                cout &lt;&lt; "The part of speech of the word is "&lt;&lt; getPOS(word) &lt;&lt; endl;
            }
            if (tries == 1) {
                cout &lt;&lt; "Definition of the word: " &lt;&lt; getDefinition(word) &lt;&lt; endl;
            }
        }
        if (tries == 0) {
            cout &lt;&lt; "The word is \"" &lt;&lt; word &lt;&lt; "\". Better luck next time! You're getting the ..ahem.. hang of it." &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; "Congrats!!!" &lt;&lt; endl;
        }
    }
}
</code></pre>
<p>The game-loop uses some helper functions that are not implemented 
yet. You will implement most of them. One of the helper function is <code class="language-plaintext highlighter-rouge">getRandomWord()</code>.
 In the game-loop, we are going to choose a random word from the 
dictionary. Use this function to get a random word from your dictionary:</p>

<pre><code class="language-Cpp">// MAKE SURE YOU INCLUDE THIS LIBRARY!
#include &lt;stdlib.h&gt;

string getRandomWord() {
    srand((unsigned) time(NULL));
    int index = rand() % g_word_count;
    return g_words[index];
}
</code></pre>
<p>Now that we have a random word from our dictionary, let’s create some
 other functions that will be used in the game-loop. Add and implement 
the following functions to your <code class="language-plaintext highlighter-rouge">.cpp</code> file:</p>

<pre><code class="language-Cpp">/*
    @param            :   The string with a word from the dictionary 
    @return           :   string of "_" based on the number of
                          characters in the given `word` 
    @post             :   Return string of "_" based on the length
                          of the given `word`.
                          For example, if the word is "game", then
                          the function would return "____". In other
                          words, a string of four "_"s.
*/
string maskWord(string word);

/*
    @param            :   The integer for the difficulty of the game
                          (0 for easy, 1 for normal, and 2 for hard) 
    @return           :   The number of tries given the `difficulty`
                          (9 for easy, 7 for normal, and 5 for hard)
    @post             :   Return the number of tries based on given
                          difficulty (0-easy: 9 tries, 1-normal: 7
                          tries, 2-Hard: 5 tries) 
*/
int getTries(int difficulty);

/*
    @param tries      :   The integer for remaining tries 
    @param difficulty :   The integer for the difficulty of the game 
                          (0 for easy, 1 for normal, and 2 for hard) 
    @post             :   prints the number of lives left and number
                          of lives used using "O" and "X". DO NOT
                          PRINT AN ENDLINE

    For example : calling `printAttemps(2, 1)` would print "OOXXXXX". 
                  Based on given `difficulty`, we know the total tries
                  is 7 (from `getTries(1)`). Also, the player has 2
                  `tries` remaining based on the given parameter.
                  Therefore, the function prints two "O"s to indicate
                  the remaining tries and 5 "X"s to indicate the tries
                  that have been used (7-2=5)          
*/
void printAttempts(int tries, int difficulty);

/*
    @param word       :   The string word from the dictionary
    @param letter     :   The char letter that that will be revealed
    @param(&amp;) current :   The string representing a masked word
    @return           :   `true` if the `letter` exists in `word`,
                          otherwise return `false`  
    @post             :   If the given `letter` exists in `word`
                          reveal the `letter` in `current` masked word
                          and return `true`. Otherwise, return `false`

    For example : Let's say we have the following main function:
                  int main(){
                      string w = "g___";
                      cout &lt;&lt; revealLetter("good", 'o', "g___") &lt;&lt; endl;
                      cout &lt;&lt;  w &lt;&lt; endl;
                  }
                  The first `cout` will print 1 because the letter 'o'
                  exists in "good". Thus, the function returned `true`.
                  The second `cout` will print "goo_". The variable `w`
                  has been modified by the function to reveal all the
                  `o`s in "good" resulting in "goo_"           
*/
bool revealLetter(string word, char letter, string &amp;current)
</code></pre>
<p>Implement and test each function before moving on to the next. Once 
you have all the functions implemented correctly, try out your game by 
running <code class="language-plaintext highlighter-rouge">gameLoop()</code> from <code class="language-plaintext highlighter-rouge">main()</code> function. Submit only one <code class="language-plaintext highlighter-rouge">.cpp</code> file to gradescope without the <code class="language-plaintext highlighter-rouge">main()</code> function.</p>

<p><strong>If you haven’t done Task A and B, don’t include the <code class="language-plaintext highlighter-rouge">gameLoop()</code>
 function in your submission to gradescope. Your program will fail. 
Ignore this message if you’ve completed Task A and B already.</strong></p>

<hr>

<p>Every project starts somewhere. While the hangman game is functional,
 it can be improved significantly. For example: we can prevent users 
from entering letters that have been entered already, we can add a GUI 
to make the experience more user-friendly and the list goes on. You can 
add your own rules to the game to make something unique that you can put
 in your Portfolio to impress your friends and potential recruiters.</p>

<hr>
<p><em>Credits: Genady Maryash, Sadab Hafiz, Yoomin Song, Ryan Vaz</em></p>

      
    </div>
    <script src="Project%201_files/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  

</body></html>